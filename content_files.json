[
  {
    "file_name": "src/ui/RadioGroup.jsx",
    "content": "// src/ui/RadioGroup.jsx\nimport React from \"react\";\n\n// Forward ref for RadioGroupItem is good.\nexport const RadioGroupItem = React.forwardRef(\n  (\n    {\n      className = \"\",\n      value,\n      checked,\n      onChange,\n      name, // Receive name prop\n      id,\n      ...props\n    },\n    ref\n  ) => {\n    return (\n      <input\n        ref={ref}\n        type=\"radio\"\n        id={id}\n        name={name} // Use the name for native grouping\n        value={value} // HTML value attribute\n        checked={checked} // Controlled component checked state\n        onChange={onChange} // Controlled component onChange handler\n        className={`h-4 w-4 accent-indigo-600 dark:accent-indigo-500 border-gray-300 dark:border-gray-600 text-indigo-600 focus:ring-indigo-500 dark:focus:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 ${className}`}\n        {...props}\n      />\n    );\n  }\n);\nRadioGroupItem.displayName = \"RadioGroupItem\";\n\nexport const RadioGroup = ({ children, className = \"\", value, onValueChange, name: groupName, ...props }) => {\n  const processChild = (child) => {\n    if (!React.isValidElement(child)) {\n      return child;\n    }\n\n    // If the child is a RadioGroupItem directly\n    if (child.type === RadioGroupItem) {\n      return React.cloneElement(child, {\n        checked: child.props.value === value,\n        onChange: () => {\n          if (onValueChange) {\n            onValueChange(child.props.value);\n          }\n        },\n        name: groupName,\n      });\n    }\n\n    // If the child has its own children, recursively process them\n    // This is to handle cases where RadioGroupItem might be wrapped (e.g., in a Label)\n    if (child.props && child.props.children) {\n      const newChildProps = {\n        ...child.props,\n        children: React.Children.map(child.props.children, processChild),\n      };\n      return React.cloneElement(child, newChildProps);\n    }\n\n    return child;\n  };\n\n  return (\n    <div role=\"radiogroup\" className={`flex items-center gap-x-4 gap-y-2 ${className}`} {...props}>\n      {React.Children.map(children, processChild)}\n    </div>\n  );\n};\n"
  },
  {
    "file_name": "src/components/HabitModal.jsx",
    "content": "// src/components/HabitModal.jsx\nimport React from \"react\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTitle,\n  DialogFooter,\n} from \"../ui/Dialog\";\nimport { Button } from \"../ui/Button\";\nimport { Input } from \"../ui/Input\";\nimport { RadioGroup, RadioGroupItem } from \"../ui/RadioGroup\";\nimport { formatDate, parseDate } from \"../utils/helpers\";\nimport { Label as CustomLabel } from \"../ui/Label\"; \n\nconst daysOfWeek = [\n  { id: 0, label: \"Sun\" }, { id: 1, label: \"Mon\" }, { id: 2, label: \"Tue\" },\n  { id: 3, label: \"Wed\" }, { id: 4, label: \"Thu\" }, { id: 5, label: \"Fri\" },\n  { id: 6, label: \"Sat\" },\n];\n\nconst Checkbox = ({ id, checked, onCheckedChange, className, children }) => {\n    const handleChange = (event) => { if (onCheckedChange) { onCheckedChange(event.target.checked); } };\n    return (\n        <CustomLabel htmlFor={id} className={`flex items-center space-x-2 text-sm font-medium text-gray-700 dark:text-gray-300 cursor-pointer ${className || ''}`}>\n            <input type=\"checkbox\" id={id} checked={!!checked} onChange={handleChange} className={'h-4 w-4 rounded border-gray-300 dark:border-gray-600 text-indigo-600 focus:ring-indigo-500 dark:bg-gray-700 dark:ring-offset-gray-800 cursor-pointer'} />\n            <span>{children}</span>\n        </CustomLabel>\n    );\n};\n\nexport const HabitModal = ({\n  isOpen,\n  onClose,\n  editingHabit,\n  habitData,\n  onDataChange,\n  onSave,\n}) => {\n\n  const {\n      title, type, startDate, endDate, scheduleType, scheduleDays, scheduleFrequency,\n      isMeasurable, unit, goal\n  } = habitData;\n\n  const handleInputChange = (field, value) => { onDataChange({ ...habitData, [field]: value }); };\n  const handleScheduleTypeChange = (value) => { const d={...habitData, scheduleType:value}; if(value!=='specific_days')d.scheduleDays=[]; if(value!=='frequency_weekly')d.scheduleFrequency=null; onDataChange(d); };\n  const handleDayToggle = (dayId) => { const cD=habitData.scheduleDays||[]; const uD=cD.includes(dayId)?cD.filter(d=>d!==dayId):[...cD, dayId].sort((a,b)=>a-b); onDataChange({...habitData, scheduleDays:uD}); };\n  const handleFrequencyChange = (e) => { const v=e.target.value; const f=v===''?null:parseInt(v,10); if(v===''||(!isNaN(f)&&f>0&&f<=7))onDataChange({...habitData,scheduleFrequency:f}); else if(!isNaN(f)&&f<=0)onDataChange({...habitData,scheduleFrequency:null}); };\n  const handleMeasurableToggle = (checked) => { const d={...habitData,isMeasurable:checked}; if(!checked){d.unit='';d.goal=null;} onDataChange(d); };\n  const handleUnitChange = (e) => { onDataChange({ ...habitData, unit: e.target.value }); };\n  const handleGoalChange = (e) => { const v=e.target.value; const gV=v===''?null:parseFloat(v); if(v===''||(!isNaN(gV)&&gV>0))onDataChange({...habitData,goal:gV}); else if(!isNaN(gV)&&gV<=0)onDataChange({...habitData,goal:null}); };\n\n  const isFormValid = () => { if(!title||!title.trim())return false; const currentScheduleType=scheduleType||'daily'; if(currentScheduleType==='specific_days'&&(!scheduleDays||scheduleDays.length===0))return false; if(currentScheduleType==='frequency_weekly'&&(scheduleFrequency===null||scheduleFrequency<=0))return false; if(isMeasurable&&(!unit||!unit.trim()||goal===null||goal<=0))return false; const sD=parseDate(startDate);const eD=endDate?parseDate(endDate):null; if(!sD)return false; if(eD&&sD>eD)return false; return true; };\n\n  return (\n    <Dialog open={isOpen} onClose={onClose}>\n      <DialogContent className=\"max-h-[90vh] overflow-y-auto scrollbar-thin\">\n        <DialogHeader><DialogTitle>{editingHabit ? \"Edit Habit\" : \"Add New Habit\"}</DialogTitle></DialogHeader>\n        <form id=\"habit-form\" onSubmit={(e) => { e.preventDefault(); onSave(); }}>\n          <div className=\"space-y-4 pb-4\">\n            <div>\n              <CustomLabel htmlFor=\"habit-title-modal\">Title <span className=\"text-red-500\">*</span></CustomLabel>\n              <Input id=\"habit-title-modal\" value={title} onChange={(e)=>handleInputChange(\"title\", e.target.value)} placeholder=\"E.g., Exercise daily\" className=\"w-full mt-1\" autoFocus required maxLength={100}/>\n            </div>\n\n            <div>\n              <CustomLabel className=\"mb-2 block\">Habit Type</CustomLabel>\n              <RadioGroup name=\"habitTypeModal\" value={type || 'good'} onValueChange={(value) => handleInputChange(\"type\", value)} className=\"flex space-x-4 mt-1\">\n                <CustomLabel htmlFor=\"type-good-modal\" className=\"flex items-center space-x-2 text-sm font-medium text-gray-700 dark:text-gray-300 cursor-pointer\">\n                  <RadioGroupItem value=\"good\" id=\"type-good-modal\" />\n                  <span>Build Good</span>\n                </CustomLabel>\n                <CustomLabel htmlFor=\"type-bad-modal\" className=\"flex items-center space-x-2 text-sm font-medium text-gray-700 dark:text-gray-300 cursor-pointer\">\n                  <RadioGroupItem value=\"bad\" id=\"type-bad-modal\" />\n                  <span>Break Bad</span>\n                </CustomLabel>\n              </RadioGroup>\n            </div>\n\n            <div className=\"pt-2 space-y-3\">\n                <Checkbox id=\"is-measurable-modal\" checked={isMeasurable||false} onCheckedChange={handleMeasurableToggle}>Track quantity</Checkbox>\n                {isMeasurable && (\n                    <div className=\"grid grid-cols-1 sm:grid-cols-2 gap-4 pl-6\">\n                        <div>\n                             <CustomLabel htmlFor=\"habit-unit-modal\" className=\"text-xs\">Unit <span className=\"text-red-500\">*</span></CustomLabel>\n                             <Input id=\"habit-unit-modal\" value={unit||''} onChange={handleUnitChange} placeholder=\"minutes, glasses, etc.\" className=\"w-full mt-1\" required={isMeasurable} maxLength={30}/>\n                        </div>\n                         <div>\n                             <CustomLabel htmlFor=\"habit-goal-modal\" className=\"text-xs\">Daily Goal <span className=\"text-red-500\">*</span></CustomLabel>\n                             <Input id=\"habit-goal-modal\" type=\"number\" value={goal??''} onChange={handleGoalChange} placeholder=\"e.g., 8, 15\" className=\"w-full mt-1\" required={isMeasurable} min=\"0.01\" step=\"any\"/>\n                        </div>\n                    </div>\n                )}\n            </div>\n\n            <div className=\"pt-2\">\n                 <CustomLabel className=\"mb-2 block\">Schedule</CustomLabel>\n                 <RadioGroup name=\"scheduleTypeModal\" value={scheduleType||'daily'} onValueChange={handleScheduleTypeChange} className=\"grid grid-cols-2 sm:grid-cols-3 gap-x-4 gap-y-2 mt-1\">\n                     <CustomLabel htmlFor=\"sch-daily-modal\" className=\"flex items-center space-x-2 text-sm font-medium text-gray-700 dark:text-gray-300 cursor-pointer\">\n                        <RadioGroupItem value=\"daily\" id=\"sch-daily-modal\" />\n                        <span>Daily</span>\n                     </CustomLabel>\n                     <CustomLabel htmlFor=\"sch-specific-modal\" className=\"flex items-center space-x-2 text-sm font-medium text-gray-700 dark:text-gray-300 cursor-pointer\">\n                        <RadioGroupItem value=\"specific_days\" id=\"sch-specific-modal\" />\n                        <span>Specific Days</span>\n                     </CustomLabel>\n                     <CustomLabel htmlFor=\"sch-frequency-modal\" className=\"flex items-center space-x-2 text-sm font-medium text-gray-700 dark:text-gray-300 cursor-pointer\">\n                        <RadioGroupItem value=\"frequency_weekly\" id=\"sch-frequency-modal\" />\n                        <span>X times/week</span>\n                     </CustomLabel>\n                 </RadioGroup>\n                 {(scheduleType||'daily') === 'specific_days' && (\n                     <div className=\"mt-3 p-3 border rounded-md dark:border-gray-700 bg-gray-50 dark:bg-gray-800/30\">\n                         <CustomLabel className=\"block text-xs font-medium text-gray-600 dark:text-gray-400 mb-2\">Select Days:</CustomLabel>\n                         <div className=\"grid grid-cols-4 sm:grid-cols-7 gap-2\">\n                             {daysOfWeek.map(day => (<Checkbox key={day.id} id={`day-${day.id}-modal`} checked={(scheduleDays||[]).includes(day.id)} onCheckedChange={()=>handleDayToggle(day.id)}>{day.label}</Checkbox>))}\n                         </div>\n                     </div>)}\n                 {(scheduleType||'daily') === 'frequency_weekly' && (\n                     <div className=\"mt-3 p-3 border rounded-md dark:border-gray-700 bg-gray-50 dark:bg-gray-800/30\">\n                         <CustomLabel htmlFor=\"freq-input-modal\" className=\"block text-xs font-medium text-gray-600 dark:text-gray-400 mb-1\">Times per week? <span className=\"text-red-500\">*</span></CustomLabel>\n                         <Input id=\"freq-input-modal\" type=\"number\" min=\"1\" max=\"7\" step=\"1\" value={scheduleFrequency??''} onChange={handleFrequencyChange} placeholder=\"e.g., 3\" className=\"w-20 mt-1\" required={(scheduleType||'daily')==='frequency_weekly'}/>\n                     </div>)}\n             </div>\n\n            <div className=\"grid grid-cols-1 sm:grid-cols-2 gap-4 pt-2\">\n              <div>\n                <CustomLabel htmlFor=\"habit-start-modal\">Start Date <span className=\"text-red-500\">*</span></CustomLabel>\n                <Input id=\"habit-start-modal\" type=\"date\" required value={startDate} onChange={(e)=>handleInputChange(\"startDate\", e.target.value)} className=\"w-full mt-1\" max={formatDate(new Date(new Date().getFullYear() + 10, 11, 31))}/>\n              </div>\n              <div>\n                <CustomLabel htmlFor=\"habit-end-modal\">End Date <span className=\"text-xs\">(Optional)</span></CustomLabel>\n                <Input id=\"habit-end-modal\" type=\"date\" value={endDate||''} onChange={(e)=>handleInputChange(\"endDate\", e.target.value||null)} className=\"w-full mt-1\" min={startDate||undefined} max={formatDate(new Date(new Date().getFullYear() + 20, 11, 31))}/>\n              </div>\n            </div>\n          </div>\n          <DialogFooter>\n            <Button type=\"button\" variant=\"outline\" onClick={onClose}>Cancel</Button>\n            <Button type=\"submit\" form=\"habit-form\" variant=\"default\" disabled={!isFormValid()} className=\"bg-purple-600 hover:bg-purple-700 dark:bg-purple-500 dark:hover:bg-purple-600 text-white disabled:opacity-50 disabled:cursor-not-allowed\">\n              {editingHabit ? \"Save Changes\" : \"Add Habit\"}\n            </Button>\n          </DialogFooter>\n        </form>\n      </DialogContent>\n    </Dialog>\n  );\n};\n"
  },
  {
    "file_name": "src/pages/ManageHabitsPage.jsx",
    "content": "// src/pages/ManageHabitsPage.jsx\nimport React, { useState, useMemo } from 'react';\nimport { Card, CardHeader, CardTitle, CardContent, CardFooter } from '../ui/Card';\nimport { Button } from '../ui/Button';\nimport { Input } from '../ui/Input';\nimport { RadioGroup, RadioGroupItem } from '../ui/RadioGroup';\nimport { Label as CustomLabel } from '../ui/Label';\nimport { ListChecks, Plus, Edit, Trash2 } from 'lucide-react';\n\nconst ManageHabitsPage = ({ habits, openModalForEditHabit, handleDeleteHabitCallback, openModalForNewHabit, habitLog }) => {\n  const [searchTerm, setSearchTerm] = useState('');\n  const [filterType, setFilterType] = useState('all'); // 'all', 'good', 'bad'\n  const [sortBy, setSortBy] = useState('title_asc');\n\n  const getHabitWithStreak = (habit) => {\n    let currentStreak = 0;\n    // Placeholder for actual streak calculation.\n    return { ...habit, currentStreak }; \n  };\n\n  const filteredAndSortedHabits = useMemo(() => {\n    if (!habits) return [];\n    let processedHabits = habits.map(habit => getHabitWithStreak(habit));\n\n    processedHabits = processedHabits.filter(habit => {\n      const matchesSearchTerm = habit.title.toLowerCase().includes(searchTerm.toLowerCase());\n      const matchesType = filterType === 'all' || habit.type === filterType;\n      return matchesSearchTerm && matchesType;\n    });\n\n    processedHabits.sort((a, b) => {\n      switch (sortBy) {\n        case 'title_asc': return a.title.localeCompare(b.title);\n        case 'title_desc': return b.title.localeCompare(a.title);\n        case 'startDate_asc': return new Date(a.startDate) - new Date(b.startDate);\n        case 'startDate_desc': return new Date(b.startDate) - new Date(a.startDate);\n        case 'streak_desc': return (b.currentStreak || 0) - (a.currentStreak || 0);\n        case 'streak_asc': return (a.currentStreak || 0) - (b.currentStreak || 0);\n        default: return 0;\n      }\n    });\n    return processedHabits;\n  }, [habits, searchTerm, filterType, sortBy, habitLog]);\n\n  return (\n    <div className=\"space-y-6 h-full flex flex-col\">\n      <div className=\"flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4 flex-shrink-0\">\n        <h2 className=\"text-2xl font-semibold text-gray-800 dark:text-gray-100 flex items-center\">\n          <ListChecks size={28} className=\"mr-3 text-indigo-600 dark:text-indigo-400\" />\n          Manage All Habits\n        </h2>\n        <Button onClick={openModalForNewHabit} className=\"bg-indigo-600 hover:bg-indigo-700 text-white whitespace-nowrap\">\n          <Plus size={18} className=\"mr-1.5\" /> Add New Habit\n        </Button>\n      </div>\n\n      <Card className='flex-shrink-0'>\n        <CardContent className=\"pt-4 pb-4 space-y-4 md:space-y-0 md:flex md:flex-wrap md:justify-between md:items-end gap-4\">\n          <div className='flex-grow min-w-[200px]'>\n            <CustomLabel htmlFor=\"search-habits-manage\">Search Habits</CustomLabel>\n            <Input\n              id=\"search-habits-manage\"\n              type=\"text\"\n              placeholder=\"Search by title...\"\n              value={searchTerm}\n              onChange={(e) => setSearchTerm(e.target.value)}\n              className=\"w-full mt-1\"\n            />\n          </div>\n          <div className='flex items-end gap-4 flex-wrap'>\n            <div>\n              <CustomLabel className=\"mb-1.5 block\">Filter by Type</CustomLabel>\n              <RadioGroup name=\"filterTypeManagePage\" value={filterType} onValueChange={setFilterType} className=\"flex space-x-3 items-center mt-1\">\n                <CustomLabel htmlFor=\"type-all-managepage\" className=\"flex items-center space-x-1.5 text-sm font-normal cursor-pointer mb-0\">\n                    <RadioGroupItem value=\"all\" id=\"type-all-managepage\" />\n                    <span>All</span>\n                </CustomLabel>\n                <CustomLabel htmlFor=\"type-good-filter-managepage\" className=\"flex items-center space-x-1.5 text-sm font-normal cursor-pointer mb-0\">\n                    <RadioGroupItem value=\"good\" id=\"type-good-filter-managepage\" />\n                    <span>Good</span>\n                </CustomLabel>\n                <CustomLabel htmlFor=\"type-bad-filter-managepage\" className=\"flex items-center space-x-1.5 text-sm font-normal cursor-pointer mb-0\">\n                    <RadioGroupItem value=\"bad\" id=\"type-bad-filter-managepage\" />\n                    <span>Bad</span>\n                </CustomLabel>\n              </RadioGroup>\n            </div>\n            <div>\n              <CustomLabel htmlFor=\"sort-by-manage\">Sort By</CustomLabel>\n              <select \n                id=\"sort-by-manage\" \n                value={sortBy} \n                onChange={(e) => setSortBy(e.target.value)}\n                className=\"h-10 w-full sm:w-auto rounded-md border border-gray-300 bg-white dark:bg-gray-900 dark:border-gray-700 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 dark:text-gray-50 mt-1\"\n              >\n                <option value=\"title_asc\">Title (A-Z)</option>\n                <option value=\"title_desc\">Title (Z-A)</option>\n                <option value=\"startDate_asc\">Start Date (Oldest)</option>\n                <option value=\"startDate_desc\">Start Date (Newest)</option>\n                <option value=\"streak_desc\">Streak (Highest First)</option>\n                <option value=\"streak_asc\">Streak (Lowest First)</option>\n              </select>\n            </div>\n          </div>\n        </CardContent>\n      </Card>\n\n      <div className=\"flex-grow overflow-y-auto scrollbar-thin pr-1 pb-4\">\n        {filteredAndSortedHabits && filteredAndSortedHabits.length > 0 ? (\n          <div className=\"grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4\">\n            {filteredAndSortedHabits.map(habit => (\n              <Card key={habit.id} className=\"bg-white dark:bg-gray-800 shadow-sm hover:shadow-md transition-shadow flex flex-col\">\n                <CardHeader className=\"pb-2\">\n                  <CardTitle className=\"text-md truncate\" title={habit.title}>{habit.title}</CardTitle>\n                </CardHeader>\n                <CardContent className=\"text-xs text-gray-600 dark:text-gray-400 space-y-1 flex-grow\">\n                  <p>Type: <span className=\"font-medium\">{habit.type === 'bad' ? 'Break Bad' : 'Build Good'}</span></p>\n                  <p>Start Date: <span className=\"font-medium\">{habit.startDate}</span></p>\n                  {habit.endDate && <p>End Date: <span className=\"font-medium\">{habit.endDate}</span></p>}\n                  <p>Schedule: <span className=\"font-medium\">{habit.scheduleType || 'Daily'}</span></p>\n                  {habit.isMeasurable && <p>Goal: <span className=\"font-medium\">{habit.goal} {habit.unit}</span></p>}\n                </CardContent>\n                <CardFooter className=\"p-3 border-t dark:border-gray-700 flex justify-end space-x-2 mt-auto\">\n                  <Button variant=\"outline\" size=\"icon_sm\" onClick={() => openModalForEditHabit(habit)} title=\"Edit Habit\">\n                    <Edit size={14} />\n                  </Button>\n                  <Button variant=\"destructive\" size=\"icon_sm\" onClick={() => {\n                    if (confirm(`Are you sure you want to delete \"${habit.title}\"? This cannot be undone.`)) {\n                        handleDeleteHabitCallback(habit.id);\n                    }\n                  }} title=\"Delete Habit\">\n                    <Trash2 size={14} />\n                  </Button>\n                </CardFooter>\n              </Card>\n            ))}\n          </div>\n        ) : (\n          <Card className=\"bg-white dark:bg-gray-800 mt-4\">\n            <CardContent className=\"pt-6 pb-6 text-center text-gray-500 dark:text-gray-400\">\n              <p>{searchTerm || filterType !== 'all' ? 'No habits match your criteria.' : 'No habits found. Start by adding a new habit!'}</p>\n            </CardContent>\n          </Card>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default ManageHabitsPage;\n"
  },
  {
    "file_name": "src/App.jsx",
    "content": "// src/App.jsx\nimport React, {\n  useState,\n  useEffect,\n  useCallback,\n  useMemo,\n  useRef,\n} from \"react\";\nimport { BrowserRouter as Router, Routes, Route, NavLink } from 'react-router-dom';\n\n// Firebase Imports\nimport { db } from \"./firebaseConfig\";\nimport {\n  collection,\n  query,\n  orderBy,\n  onSnapshot,\n  doc,\n  setDoc,\n  deleteDoc,\n  updateDoc,\n  deleteField,\n  getDocs,\n  writeBatch\n} from \"firebase/firestore\";\n\n// Hooks\nimport { useDarkMode } from \"./hooks/useDarkMode\";\n\n// Components\nimport { Header } from \"./components/Header\";\nimport { HabitModal } from \"./components/HabitModal\";\nimport { ChatPanel } from \"./components/ChatPanel\";\nimport { Button } from \"./ui/Button\";\n\n// Pages\nimport DashboardPage from './pages/DashboardPage';\nimport ManageHabitsPage from './pages/ManageHabitsPage';\nimport AnalyticsPage from './pages/AnalyticsPage';\nimport SettingsPage from './pages/SettingsPage';\n\n// Utils & Constants\nimport { formatDate, parseDate, isHabitScheduledForDate } from \"./utils/helpers\";\nimport { fetchChatResponse } from \"./utils/api\";\nimport * as Actions from \"./constants\";\n\n// Icons\nimport { MessageSquare, LayoutDashboard, ListChecks, LineChart, Settings as SettingsIcon, Menu, X as CloseIcon } from \"lucide-react\";\n\nconst habitsCollectionRef = collection(db, \"habits\");\nconst habitLogCollectionRef = collection(db, \"habitLog\");\n\nconst initialHabitModalData = {\n  title: \"\",\n  type: \"good\",\n  startDate: formatDate(new Date()),\n  endDate: \"\",\n  scheduleType: \"daily\",\n  scheduleDays: [],\n  scheduleFrequency: null,\n  isMeasurable: false,\n  unit: \"\",\n  goal: null,\n  category: \"\",\n};\n\nfunction App() {\n  const [isDarkMode, toggleDarkMode] = useDarkMode();\n  const [habits, setHabits] = useState([]);\n  const [habitLog, setHabitLog] = useState({});\n  const [isHabitModalOpen, setIsHabitModalOpen] = useState(false);\n  const [editingHabit, setEditingHabit] = useState(null);\n  const [habitModalData, setHabitModalData] = useState(initialHabitModalData);\n  const [chatHistory, setChatHistory] = useState([]);\n  const [chatInput, setChatInput] = useState(\"\");\n  const [isChatLoading, setIsChatLoading] = useState(false);\n  const [isChatOpen, setIsChatOpen] = useState(false);\n  const [pendingActionData, setPendingActionData] = useState(null);\n  const [awaitingConfirmation, setAwaitingConfirmation] = useState(false);\n  const [userName, setUserName] = useState(\"User\");\n  const recognitionRef = useRef(null);\n  const [isListening, setIsListening] = useState(false);\n  const chatInputRef = useRef(null);\n  const [focusChatInput, setFocusChatInput] = useState(false);\n  const [isLoadingData, setIsLoadingData] = useState(true);\n  const [notificationPermission, setNotificationPermission] = useState(\"default\");\n  const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false);\n\n  useEffect(() => {\n    setIsLoadingData(true);\n    let isInitial = true;\n    const qH = query(habitsCollectionRef, orderBy(\"title\"));\n    const unH = onSnapshot(\n      qH,\n      (qs) => {\n        const d = qs.docs.map((doc) => ({ id: doc.id, ...doc.data() }));\n        setHabits(d);\n        if (isInitial) {\n          setIsLoadingData(false);\n          isInitial = false;\n        }\n      },\n      (e) => {\n        console.error(\"Habits listener err:\", e);\n        setIsLoadingData(false);\n      }\n    );\n    const qL = query(habitLogCollectionRef);\n    const unL = onSnapshot(\n      qL,\n      (qs) => {\n        const d = {};\n        qs.forEach((doc) => (d[doc.id] = doc.data()));\n        setHabitLog(d);\n      },\n      (e) => console.error(\"Logs listener err:\", e)\n    );\n    return () => {\n      unH();\n      unL();\n    };\n  }, []);\n\n  useEffect(() => {\n    if (\"Notification\" in window) setNotificationPermission(Notification.permission);\n    else {\n      console.warn(\"Notifications not supported.\");\n      setNotificationPermission(\"denied\");\n    }\n  }, []);\n\n  const requestNotificationPermission = useCallback(async () => {\n    if (!(\"Notification\" in window)) {\n      alert(\"Notifications not supported.\");\n      setNotificationPermission(\"denied\");\n      return;\n    }\n    if (notificationPermission === \"granted\" || notificationPermission === \"denied\") return;\n    const p = await Notification.requestPermission();\n    setNotificationPermission(p);\n    if (p === \"granted\") new Notification(\"Habit Tracker AI\", { body: \"Notifications enabled!\", icon: \"/vite.svg\" });\n    else alert(\"Notifications denied.\");\n  }, [notificationPermission]);\n\n  const upsertHabit = useCallback(async (habitDataToSave) => {\n    const habitId = habitDataToSave.id || `habit_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n    const habitDocRef = doc(db, \"habits\", habitId);\n    const isMeasurable = habitDataToSave.isMeasurable || false;\n    const scheduleType = habitDataToSave.scheduleType || \"daily\";\n    const trimmedCategory = habitDataToSave.category?.trim() || null;\n\n    const newHabitData = {\n      title: (habitDataToSave.title || \"\").trim(),\n      type: habitDataToSave.type === \"bad\" ? \"bad\" : \"good\",\n      startDate: habitDataToSave.startDate || formatDate(new Date()),\n      endDate: habitDataToSave.endDate || null,\n      category: trimmedCategory,\n      isMeasurable: isMeasurable,\n      unit: isMeasurable ? (habitDataToSave.unit || \"\").trim() : deleteField(),\n      goal: isMeasurable ? habitDataToSave.goal || null : deleteField(),\n      scheduleType: scheduleType === \"daily\" ? deleteField() : scheduleType,\n      scheduleDays: scheduleType === \"specific_days\" ? (habitDataToSave.scheduleDays || []).sort((a, b) => a - b) : deleteField(),\n      scheduleFrequency: scheduleType === \"frequency_weekly\" ? habitDataToSave.scheduleFrequency || null : deleteField(),\n    };\n\n    if (!newHabitData.title) { alert(\"Habit title required.\"); return false; }\n    const startD = parseDate(newHabitData.startDate);\n    const endD = newHabitData.endDate ? parseDate(newHabitData.endDate) : null;\n    if (!startD || (newHabitData.endDate && !endD) || (endD && startD > endD)) { alert(\"Invalid date range.\"); return false; }\n    if (scheduleType === \"specific_days\" && (!newHabitData.scheduleDays || newHabitData.scheduleDays.length === 0)) { alert(\"Select days for 'Specific Days'.\"); return false; }\n    if (scheduleType === \"frequency_weekly\" && (newHabitData.scheduleFrequency === null || newHabitData.scheduleFrequency <= 0)) { alert(\"Enter valid frequency.\"); return false; }\n    if (isMeasurable && newHabitData.unit === undefined) { if (!habitDataToSave.unit || !habitDataToSave.unit.trim()) { alert(\"Unit required for measurable habits.\"); return false; } newHabitData.unit = habitDataToSave.unit.trim(); }\n    if (isMeasurable && (newHabitData.goal === null || newHabitData.goal === undefined || newHabitData.goal <= 0)) { if (habitDataToSave.goal === null || habitDataToSave.goal === undefined || habitDataToSave.goal <= 0) { alert(\"Valid goal (> 0) required for measurable habits.\"); return false; } newHabitData.goal = habitDataToSave.goal; }\n\n    const finalHabitData = Object.entries(newHabitData).reduce((acc, [key, value]) => {\n      if (value !== undefined) acc[key] = value;\n      return acc;\n    }, {});\n\n    try {\n      await setDoc(habitDocRef, finalHabitData, { merge: true });\n      return true;\n    } catch (error) {\n      console.error(\"Error saving habit:\", error);\n      alert(\"Failed to save habit.\");\n      return false;\n    }\n  }, []);\n\n  const handleDeleteHabitCallback = useCallback(async (id) => {\n    if (!id) return;\n    const dR = doc(db, \"habits\", id);\n    try {\n      await deleteDoc(dR);\n    } catch (e) {\n      console.error(e);\n      alert(\"Failed to delete habit.\");\n    }\n  }, []);\n\n  const updateHabitLog = useCallback(async (habitId, date, value) => {\n    const dateStr = formatDate(date);\n    if (!dateStr || !habitId) { console.error(\"Invalid args for updateHabitLog\", { habitId, dateStr, value }); return; }\n    const logDocRef = doc(db, \"habitLog\", dateStr);\n    const logData = { [habitId]: value };\n    try {\n      if (value === null || value === undefined) await updateDoc(logDocRef, { [habitId]: deleteField() });\n      else await setDoc(logDocRef, logData, { merge: true });\n    } catch (error) {\n      if (!(error.code === \"not-found\" && (value === null || value === undefined))) {\n        console.error(\"[updateHabitLog] Error:\", error);\n        alert(\"Failed to update habit log.\");\n      }\n    }\n  }, []);\n\n  const findHabitIdByTitle = useCallback((title) => {\n    if (!title || !Array.isArray(habits)) return null;\n    const s = title.trim().toLowerCase();\n    if (!s) return null;\n    const m = habits.find((h) => h.title.trim().toLowerCase() === s);\n    return m ? m.id : null;\n  }, [habits]);\n\n  const openModalForNewHabit = useCallback(() => {\n    setEditingHabit(null);\n    setHabitModalData(initialHabitModalData);\n    setIsHabitModalOpen(true);\n  }, []);\n\n  const openModalForEditHabit = useCallback((habit) => {\n    setEditingHabit(habit);\n    setHabitModalData({ title: habit.title || \"\", type: habit.type || \"good\", startDate: habit.startDate || formatDate(new Date()), endDate: habit.endDate || \"\", scheduleType: habit.scheduleType || \"daily\", scheduleDays: habit.scheduleDays || [], scheduleFrequency: habit.scheduleFrequency ?? null, isMeasurable: habit.isMeasurable || false, unit: habit.unit || \"\", goal: habit.goal ?? null, category: habit.category || \"\" });\n    setIsHabitModalOpen(true);\n  }, []);\n\n  const closeHabitModal = useCallback(() => {\n    setIsHabitModalOpen(false);\n    setEditingHabit(null);\n    setHabitModalData(initialHabitModalData);\n  }, []);\n\n  const handleHabitModalSave = useCallback(async () => {\n    console.log('[App.jsx] Attempting to save habit:', habitModalData);\n    const success = await upsertHabit({\n      id: editingHabit?.id,\n      ...habitModalData,\n    });\n    console.log('[App.jsx] Upsert success:', success, '- Calling closeHabitModal.');\n    if (success) {\n      closeHabitModal();\n    } else {\n      console.log('[App.jsx] Upsert failed, modal will not close.');\n    }\n  }, [upsertHabit, editingHabit, habitModalData, closeHabitModal]);\n\n  const toggleChat = useCallback(() => {\n    setIsChatOpen((p) => !p);\n    if (!isChatOpen) setTimeout(() => setFocusChatInput(true), 350);\n  }, [isChatOpen]);\n\n  const handleSendChatMessage = useCallback(async () => {\n    const msgTxt = chatInput.trim();\n    const lowerMsg = msgTxt.toLowerCase();\n    if (!msgTxt && !awaitingConfirmation) return;\n    if (isChatLoading && !awaitingConfirmation) return;\n    const userMsg = { sender: \"user\", text: msgTxt };\n    setChatHistory((p) => [...p, userMsg]);\n    setChatInput(\"\");\n    if (awaitingConfirmation && pendingActionData) {\n      try {\n        const c = lowerMsg;\n        let r = \"\";\n        let d = false;\n        if (c === \"yes\" || c === \"y\") d = true;\n        else if (c === \"no\" || c === \"n\") r = \"Cancelled.\";\n        else r = `Confirm yes/no. ${pendingActionData.confirmationPrompt}`;\n        if (d) {\n          try {\n            switch (pendingActionData.action) {\n              case Actions.ACTION_DELETE_HABIT:\n                await Promise.all(pendingActionData.habitIds?.map((id) => handleDeleteHabitCallback(id)) || []);\n                r = `Deleted \"${pendingActionData.title || \"habit\"}\".`;\n                break;\n              case Actions.ACTION_SUGGEST_HABITS:\n                const rs = await Promise.all(pendingActionData.habits?.map((h) => upsertHabit(h)) || []);\n                r = `Added ${rs.filter((s) => s).length} suggested habits.`;\n                break;\n              case Actions.ACTION_DELETE_ALL_HABITS:\n                try {\n                  const q = query(habitsCollectionRef);\n                  const qs = await getDocs(q);\n                  const batch = writeBatch(db);\n                  qs.docs.forEach(docSnapshot => batch.delete(docSnapshot.ref));\n                  const logDocsSnapshot = await getDocs(collection(db, 'habitLog'));\n                  logDocsSnapshot.forEach(logDoc => batch.delete(logDoc.ref));\n                  await batch.commit();\n                  setHabits([]); \n                  setHabitLog({}); \n                  r = `Deleted all ${qs.size} habits and their logs.`;\n                } catch (e) { r = \"Error deleting all habits.\"; console.error(e); }\n                break;\n              case Actions.ACTION_COMPLETE_ALL_HABITS_TODAY:\n                const t = new Date();\n                const aNM = habits.filter((h) => !h.isMeasurable && isHabitScheduledForDate(h, t));\n                if (aNM.length > 0) {\n                  await Promise.all(aNM.map((h) => updateHabitLog(h.id, t, true)));\n                  r = `Marked ${aNM.length} non-measurable habits as done for today.`;\n                } else r = \"No non-measurable habits scheduled for today.\";\n                break;\n              default: r = \"Confirmed (unknown action).\";\n            }\n          } catch (e) { r = \"Error performing confirmed action.\"; console.error(e); }\n        }\n        if (r) {\n          console.log('[App.jsx] AI Confirmation/Action Response:', r);\n          setChatHistory((p) => [...p, { sender: \"bot\", text: r }]);\n        }\n        if (d || c === \"no\" || c === \"n\") { setPendingActionData(null); setAwaitingConfirmation(false); }\n        else { setAwaitingConfirmation(true); }\n      } catch (e) { console.error(e); setChatHistory((p) => [...p, { sender: \"bot\", text: \"Confirmation processing error.\" }]); setPendingActionData(null); setAwaitingConfirmation(false); }\n      finally { if (!(lowerMsg === \"no\" || lowerMsg === \"n\")) setTimeout(() => setFocusChatInput(true), 0); }\n      return;\n    }\n    setIsChatLoading(true);\n    try {\n      const cH = [...chatHistory];\n      const bR = await fetchChatResponse(habits, habitLog, cH, msgTxt, userName);\n      let rC = false; let cP = \"\"; let cM = \"\"; let aD = null;\n      if (!bR || (!bR.action && !bR.text)) cM = \"Invalid AI response.\";\n      else if (bR.action && bR.action !== Actions.ACTION_GENERAL_CHAT) {\n        aD = { ...bR };\n        try {\n          switch (bR.action) {\n            case Actions.ACTION_ADD_HABIT:\n              const added = await upsertHabit(bR);\n              cM = added ? `Added habit: \"${bR.title}\".` : `Could not add habit.`;\n              break;\n            case Actions.ACTION_BATCH_ACTIONS:\n              if (Array.isArray(bR.actions)) {\n                let ad = 0, fa = [], du = [];\n                await Promise.all(bR.actions.map(async (a) => {\n                  if (a.action === Actions.ACTION_ADD_HABIT && a.title) {\n                    if (habits.some((h) => h.title.toLowerCase() === a.title.toLowerCase())) du.push(a.title);\n                    else if (await upsertHabit(a)) ad++;\n                    else fa.push(a.title);\n                  } else if (a.title) fa.push(a.title);\n                }));\n                let ms = [];\n                if (ad > 0) ms.push(`Added ${ad} habits.`);\n                if (du.length > 0) ms.push(`Duplicate habits not added: ${du.join(\", \")}.`);\n                if (fa.length > 0) ms.push(`Failed to add: ${fa.join(\", \")}.`);\n                cM = ms.length > 0 ? ms.join(\" \") : \"Batch action failed or no valid actions.\";\n              } else cM = \"Invalid batch actions format.\";\n              break;\n            case Actions.ACTION_DELETE_HABIT:\n              const idDel = findHabitIdByTitle(bR.title);\n              if (idDel) { rC = true; aD = { ...aD, habitIds: [idDel], title: bR.title, confirmationPrompt: `Are you sure you want to delete the habit \"${bR.title}\"? (yes/no)` }; cP = aD.confirmationPrompt; }\n              else cM = `Habit \"${bR.title}\" not found.`;\n              break;\n            case Actions.ACTION_COMPLETE_HABIT_DATE:\n              const idL = findHabitIdByTitle(bR.title);\n              const dSL = bR.date || formatDate(new Date());\n              const sL = bR.status;\n              const dL = parseDate(dSL);\n              const hTL = habits.find((h) => h.id === idL);\n              if (idL && dL && typeof sL === \"boolean\") {\n                if (hTL?.isMeasurable) cM = `Cannot mark measurable habit \"${bR.title}\" as simply done/missed via chat. Please log its value directly.`;\n                else { await updateHabitLog(idL, dL, sL); const sTxt = sL ? (hTL?.type === \"bad\" ? \"avoided\" : \"done\") : (hTL?.type === \"bad\" ? \"indulged\" : \"missed\"); cM = `Marked \"${bR.title}\" as ${sTxt} for ${dSL}.`; }\n              } else cM = `Could not log habit \"${bR.title}\". Please ensure title, date, and status are correct.`;\n              break;\n            case Actions.ACTION_SUGGEST_HABITS:\n              if (Array.isArray(bR.habits) && bR.habits.length > 0) {\n                const vS = bR.habits.filter((h) => h && h.title);\n                if (vS.length > 0) { rC = true; const ts = vS.map((h) => `\"${h.title}\"`).join(\", \"); aD = { ...aD, habits: vS, confirmationPrompt: `Would you like to add these suggested habits: ${ts}? (yes/no)` }; cP = aD.confirmationPrompt; }\n                else cM = \"AI suggested invalid habits.\";\n              } else cM = \"AI could not suggest habits at this time.\";\n              break;\n            case Actions.ACTION_DELETE_ALL_HABITS:\n              if (habits.length > 0) { rC = true; aD = { ...aD, confirmationPrompt: `Are you sure you want to delete all ${habits.length} habits? This action cannot be undone. (yes/no)` }; cP = aD.confirmationPrompt; }\n              else cM = \"There are no habits to delete.\";\n              break;\n            case Actions.ACTION_COMPLETE_ALL_HABITS_TODAY:\n              const tCAT = new Date();\n              const aNM = habits.filter((h) => !h.isMeasurable && isHabitScheduledForDate(h, tCAT));\n              if (aNM.length > 0) { rC = true; aD = { ...aD, confirmationPrompt: `Mark all ${aNM.length} non-measurable habits scheduled for today as done/avoided? (yes/no)` }; cP = aD.confirmationPrompt; }\n              else cM = \"No non-measurable habits are scheduled for today.\";\n              break;\n            default: cM = \"Unknown action received from AI.\"; console.warn(\"Unknown AI Action:\", bR.action);\n          }\n        } catch (e) { console.error(\"Error processing AI action:\", e); cM = \"Error processing AI action.\"; rC = false; }\n      } else {\n        cM = bR.text || \"I'm not sure how to respond to that.\";\n        const nk = [\"my name is \", \"i'm \", \"im \", \"call me \"];\n        const kf = nk.find((kw) => lowerMsg.startsWith(kw));\n        if (kf) {\n          const pN = msgTxt.substring(kf.length).trim().replace(/[^a-zA-Z\\s-]/g, \"\").trim();\n          if (pN && pN.length >= 2 && pN.length <= 30) { const fN = pN.split(\" \").map((w) => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()).join(\" \"); setUserName(fN); cM = `Nice to meet you, ${fN}! How can I help with your habits?`; }\n        }\n      }\n      if (rC && aD?.confirmationPrompt) { setPendingActionData(aD); setAwaitingConfirmation(true); cM = cP; }\n      else { setPendingActionData(null); setAwaitingConfirmation(false); }\n      \n      if (cM) {\n        console.log('[App.jsx] Bot message to add to chat:', cM);\n        setChatHistory((p) => [...p, { sender: \"bot\", text: cM }]);\n      } else if (!rC) {\n        console.warn(\"[App.jsx] No message (cM empty) from AI or action processing issue (handleSendChatMessage):\", bR);\n        setChatHistory((p) => [...p, { sender: \"bot\", text: \"Action processed or an issue occurred.\" }]);\n      }\n\n      const fw = [\"bye\", \"goodbye\", \"exit\", \"close chat\", \"close\"];\n      if (fw.includes(lowerMsg)) setTimeout(toggleChat, 1000);\n    } catch (e) { console.error(\"Critical error in chat handling:\", e); setChatHistory((p) => [...p, { sender: \"bot\", text: \"A critical error occurred with the AI assistant.\" }]); setPendingActionData(null); setAwaitingConfirmation(false); }\n    finally { setIsChatLoading(false); const fw = [\"bye\", \"goodbye\", \"exit\", \"close chat\", \"close\"]; const sc = fw.includes(lowerMsg); if (!awaitingConfirmation && !sc) setTimeout(() => setFocusChatInput(true), 0); }\n  }, [chatInput, chatHistory, habits, habitLog, isChatLoading, awaitingConfirmation, pendingActionData, userName, upsertHabit, findHabitIdByTitle, handleDeleteHabitCallback, updateHabitLog, setUserName, setHabits, setHabitLog, toggleChat, setChatInput]);\n\n  const setupSpeechRecognition = useCallback(() => {\n    const SRA = window.SpeechRecognition || window.webkitSpeechRecognition;\n    if (!SRA) return;\n    const r = new SRA();\n    r.continuous = false; r.interimResults = false; r.lang = \"en-US\";\n    r.onstart = () => { setIsListening(true); setChatInput(\"Listening...\"); };\n    r.onresult = (e) => { const t = e.results[e.results.length - 1][0].transcript.trim(); setChatInput(t); };\n    r.onerror = (e) => { console.error(\"Speech err:\", e.error); let m = `Speech err: ${e.error}`; if (e.error === \"not-allowed\" || e.error === \"service-not-allowed\") m = \"Microphone access denied.\"; else if (e.error === \"no-speech\") m = \"No speech detected.\"; else if (e.error === \"audio-capture\") m = \"Microphone error.\"; else if (e.error === \"network\") m = \"Network error during speech recognition.\"; setChatHistory((p) => [...p, { sender: \"bot\", text: m }]); setIsListening(false); if (chatInputRef.current?.value === \"Listening...\") setChatInput(\"\"); };\n    r.onend = () => { setIsListening(false); if (chatInputRef.current?.value === \"Listening...\") setChatInput(\"\"); chatInputRef.current?.focus(); };\n    recognitionRef.current = r;\n  }, [setChatHistory, setChatInput]);\n\n  useEffect(() => {\n    setupSpeechRecognition();\n    return () => recognitionRef.current?.abort();\n  }, [setupSpeechRecognition]);\n\n  const handleMicClick = useCallback(() => {\n    if (!recognitionRef.current) { setChatHistory((p) => [...p, { sender: \"bot\", text: \"Speech recognition is not available in your browser.\" }]); return; }\n    if (isListening) recognitionRef.current.stop();\n    else {\n      navigator.mediaDevices.getUserMedia({ audio: true })\n        .then(() => { setChatInput(\"\"); recognitionRef.current.start(); })\n        .catch((err) => { console.error(\"Mic access err:\", err); let t = \"Voice input error.\"; if (err.name === \"NotAllowedError\" || err.name === \"PermissionDeniedError\") t = \"Microphone access denied by user.\"; else if (err.name === \"NotFoundError\") t = \"No microphone found.\"; setChatHistory((p) => [...p, { sender: \"bot\", text: t }]); setIsListening(false); });\n    }\n  }, [isListening, setChatHistory, setChatInput]);\n\n  const NavItem = ({ to, children, icon: Icon }) => (\n    <NavLink\n      to={to}\n      className={({ isActive }) =>\n        `flex items-center space-x-3 px-3 py-2.5 rounded-md text-sm font-medium transition-colors \n        ${isActive\n          ? 'bg-indigo-100 text-indigo-700 dark:bg-indigo-700 dark:text-white'\n          : 'text-gray-600 hover:bg-gray-100 hover:text-gray-900 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-gray-50'}`\n      }\n      onClick={() => setIsMobileMenuOpen(false)}\n    >\n      {Icon && <Icon className=\"h-5 w-5\" />}\n      <span>{children}</span>\n    </NavLink>\n  );\n\n  const exportData = () => {\n    const dataToExport = { habits, habitLog };\n    const jsonString = `data:text/json;charset=utf-8,${encodeURIComponent(JSON.stringify(dataToExport, null, 2))}`;\n    const link = document.createElement(\"a\");\n    link.href = jsonString;\n    link.download = `habit_tracker_data_${formatDate(new Date())}.json`;\n    link.click();\n    link.remove();\n  };\n\n  const importData = async (file) => {\n    if (!file) return;\n    const reader = new FileReader();\n    reader.onload = async (event) => {\n      try {\n        const imported = JSON.parse(event.target.result);\n        if (imported.habits && typeof imported.habitLog === 'object') {\n          const batch = writeBatch(db);\n          const existingHabitsSnapshot = await getDocs(query(habitsCollectionRef));\n          existingHabitsSnapshot.forEach(doc => batch.delete(doc.ref));\n          const existingLogsSnapshot = await getDocs(query(habitLogCollectionRef));\n          existingLogsSnapshot.forEach(doc => batch.delete(doc.ref));\n\n          imported.habits.forEach(habit => {\n            const habitId = habit.id || `habit_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n            const newHabitRef = doc(db, \"habits\", habitId);\n            const { id, ...habitData } = habit;\n            batch.set(newHabitRef, habitData);\n          });\n\n          Object.entries(imported.habitLog).forEach(([dateStr, logs]) => {\n            const logRef = doc(db, \"habitLog\", dateStr);\n            batch.set(logRef, logs);\n          });\n\n          await batch.commit();\n          alert('Data imported successfully! Firestore data updated.');\n        } else {\n          alert('Invalid JSON file structure. Expected \"habits\" array and \"habitLog\" object.');\n        }\n      } catch (error) {\n        console.error(\"Error importing data:\", error);\n        alert('Failed to import data. Check console for errors.');\n      }\n    };\n    reader.readAsText(file);\n  };\n\n  return (\n    <Router>\n      <div className=\"flex flex-col h-screen bg-gradient-to-br from-blue-50 via-white to-purple-50 dark:from-gray-900 dark:via-black dark:to-indigo-900 font-sans text-gray-800 dark:text-gray-200 overflow-hidden\">\n        <Header userName={userName} isDarkMode={isDarkMode} toggleDarkMode={toggleDarkMode} isChatOpen={isChatOpen} />\n\n        <div className=\"flex flex-grow overflow-hidden\">\n          <nav className={`fixed lg:static lg:translate-x-0 inset-y-0 left-0 z-40 w-64 bg-white dark:bg-gray-950 border-r border-gray-200 dark:border-gray-800 transform transition-transform duration-300 ease-in-out ${isMobileMenuOpen ? 'translate-x-0 shadow-xl' : '-translate-x-full'} lg:flex flex-col space-y-1 p-4`}>\n            <NavItem to=\"/\" icon={LayoutDashboard}>Dashboard</NavItem>\n            <NavItem to=\"/manage\" icon={ListChecks}>Manage Habits</NavItem>\n            <NavItem to=\"/analytics\" icon={LineChart}>Analytics</NavItem>\n            <NavItem to=\"/settings\" icon={SettingsIcon}>Settings</NavItem>\n            {isMobileMenuOpen && <div className=\"pt-4 border-t dark:border-gray-700 mt-auto\"><Button variant=\"outline\" onClick={() => setIsMobileMenuOpen(false)} className=\"w-full\">Close Menu</Button></div>}\n          </nav>\n          \n          {isMobileMenuOpen && (\n            <div className=\"fixed inset-0 z-30 bg-black/30 lg:hidden\" onClick={() => setIsMobileMenuOpen(false)}></div>\n          )}\n\n          <main className=\"flex-grow flex flex-col overflow-y-auto scrollbar-thin scrollbar-thumb-gray-300 dark:scrollbar-thumb-gray-600 scrollbar-track-transparent p-3 sm:p-4 md:p-6 pb-20\">\n            {isLoadingData && (\n              <div className=\"fixed inset-0 bg-white/50 dark:bg-black/50 flex items-center justify-center z-50\">\n                <p className=\"text-lg font-semibold animate-pulse dark:text-white\">Loading Data...</p>\n              </div>\n            )}\n            <Routes>\n              <Route path=\"/\" element={<DashboardPage habits={habits} habitLog={habitLog} openModalForNewHabit={openModalForNewHabit} openModalForEditHabit={openModalForEditHabit} handleDeleteHabitCallback={handleDeleteHabitCallback} updateHabitLog={updateHabitLog} isLoadingData={isLoadingData} />} />\n              <Route path=\"/manage\" element={<ManageHabitsPage habits={habits} habitLog={habitLog} openModalForEditHabit={openModalForEditHabit} handleDeleteHabitCallback={handleDeleteHabitCallback} openModalForNewHabit={openModalForNewHabit} />} />\n              <Route path=\"/analytics\" element={<AnalyticsPage habits={habits} habitLog={habitLog} />} />\n              <Route path=\"/settings\" element={<SettingsPage exportData={exportData} importData={importData} />} />\n            </Routes>\n          </main>\n        </div>\n\n        <div className=\"fixed bottom-6 right-6 z-30 flex flex-col space-y-3 lg:space-y-0 lg:flex-row lg:space-x-3 items-center\">\n          <Button onClick={() => setIsMobileMenuOpen(prev => !prev)} variant=\"outline\" size=\"icon\" className=\"lg:hidden rounded-full w-12 h-12 bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm shadow-lg text-gray-700 dark:text-gray-200 hover:bg-gray-200 dark:hover:bg-gray-700\" aria-label=\"Toggle navigation menu\">\n            {isMobileMenuOpen ? <CloseIcon size={22} /> : <Menu size={22} />}\n          </Button>\n          {!isChatOpen && (\n            <Button onClick={toggleChat} variant=\"default\" size=\"icon\" className=\"rounded-full w-14 h-14 bg-indigo-600 hover:bg-indigo-700 text-white shadow-lg hover:scale-105 flex items-center justify-center\" aria-label=\"Chat Assistant\">\n              <MessageSquare size={24} />\n            </Button>\n          )}\n        </div>\n\n        <ChatPanel isOpen={isChatOpen} onClose={toggleChat} chatHistory={chatHistory} isChatLoading={isChatLoading} chatInput={chatInput} setChatInput={setChatInput} handleSendChatMessage={handleSendChatMessage} handleMicClick={handleMicClick} isListening={isListening} awaitingConfirmation={awaitingConfirmation} chatInputRef={chatInputRef} focusChatInput={focusChatInput} setFocusChatInput={setFocusChatInput} />\n        <HabitModal isOpen={isHabitModalOpen} onClose={closeHabitModal} editingHabit={editingHabit} habitData={habitModalData} onDataChange={setHabitModalData} onSave={handleHabitModalSave} />\n      </div>\n    </Router>\n  );\n}\n\nexport default App;\n"
  }
]
